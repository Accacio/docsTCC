
\chapter{Background}
\label{cha:background}
This chapter will discuss the main topics needed to understand this work, from
discrete event systems to discrete control implementation on \PLCs, a more
detailed explanation of each topic can be found on the respective cited work.
\section{Systems}

A System as defined by the Cambridge's dictionary is ``a set of connected things
or devices that operate together''. As seen two basic properties of systems are
:
\begin{itemize}
\item they are formed by grouping smaller parts
\item the smaller parts when grouped work together to carry out a specific
  function
\end{itemize}

As its definition is so abstract almost anything can be defined as a system,
physical or not, beings can be defined as systems and even economic mechanisms
can also be considered as systems.

Usually systems are modelled by a Input\slash Output process. The system is fed with a
set of inputs, it process the inputs resulting on the output set, as we can see
in \autoref{fig:ioProcModel}.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    % \node[anchor=south west,inner sep=0] (image) at (0,0) {
    %   \includegraphics[trim={0 0 0 0},clip,width=8cm]{maquete/sensores/69511_3.jpg}
    % };
    % \draw[red,ultra thick,rounded corners] (0,0) rectangle (9.4,6.2);
    % \begin{scope}[x={(image.south east)},y={(image.north west)}]
        \draw[ultra thick,rounded corners] (3.5,4) rectangle (6.5,6);
        \draw (5,5) node {\textbf{Process}};
        \draw (0,5) node {\textbf{Inputs}};
        \draw[->,>=stealth, very thick] (1,4.5) -- ++ (2.5,0);
        \draw[->,>=stealth, very thick] (1,5)   -- ++ (2.5,0);
        \draw[->,>=stealth, very thick] (1,5.5) -- ++ (2.5,0);
        \draw (10,5) node {\textbf{Outputs}};
        \draw[->,>=stealth, very thick] (6.5,4.5) -- ++ (2.5,0);
        \draw[->,>=stealth, very thick] (6.5,5)   -- ++ (2.5,0);
        \draw[->,>=stealth, very thick] (6.5,5.5) -- ++ (2.5,0);
      % \end{scope}
    \end{tikzpicture}
  \caption{Input\slash Output Process model}
    \label{fig:ioProcModel}
\end{figure}


In some systems, its inputs and outputs can't represent it's behaviour, so the
concept of state is created, and it represents the behaviour of the system in a
given instant $t$.

The states can be continuous or discrete, and the systems which these states
represent can be considered as Continuous Systems, Discrete Systems or even
Hybrid Systems, which combine both kind of states.

The systems modelled in this work are Discrete Systems, more details about other
kinds of systems as well as examples and their analysis can be found on
\cite{oppenheim1996signals} and \cite{kalouptsidis1997signal}.
\section{Discrete Event Systems}
\label{sec:discreteEventSystems}
Discrete Systems can be driven by time and by events. It means, the states can
be changed continuously by the time or instantaneously by some ensemble of events.

In this thesis we are interested in the event-driven type. Some basic mathematical
formalisms, nomenclature and representations can be developed to facilitate the
understanding. Some of those will be presented in the following sections based
on \cite{cassandras2009introduction, david2005discrete,david1989grafcet}.
\section{Languages} \label{sec:automata} A language can be defined by the Merriam-Webster's dictionary as ``a systematic
means of communicating ideas or feelings by the use of conventionalized signs,
sounds, gestures, or marks having understood meanings'' And as it is defined by
this dictionary entry we pursue to communicate the complete behaviour of the
\DES. Firstly we need to define a group, or set of marks to characterise the
singular behaviour of the system. So, we define a set $\Sigma$. This set contains
all elements which combined can create a language. Again in analogy with
linguistics, each one of these marks, the events can be compared to letters ,
provided that $\Sigma$ can be called an ``alphabet'', and the combination of its
events ``words''. Words are also called ``strings '' or even ``traces''.
Considering the use of the word ``string'' as the variable type used on several
programming languages used in this work, we prefer the use of the vocables
``word'' and ``trace''. We can also define a mark to represent an empty word,
$\epsilon$, that is, a word that is not formed by any event.

The combination process to form words is called concatenation. For instance,
given two events $a$ and $b$, the words $ab$ and $ba$ can be created concatenating these two events and there is no particular reason to suppose that $ab$ is equal to $ba$, the same way the words ``ten'' and ``net'' have different meanings in English.

We can also concatenate two words, to create a different one, we can take the
words $ab$ and $ba$ and create words like $abba$ and $baab$.

As we extended the definition of concatenation to words, we define $\epsilon$,
the empty word, as the identity element of concatenation: $w\epsilon = \epsilon
w = w$ for any word $w$.

Likewise, we can define the length of a word as the number of events contained
by this word, we denote the length with two vertical bars, given a word $w$ its
length is equal to $|w|$ and by definition $|\epsilon| = 0 $.

As we know, there is a great number of human western languages, as portuguese,
english, french, spanish etc, that roughly are formed by the same alphabet, but
overall they are formed by different combination of words. Similar things can
happen with languages that define the \DESs, so we can define as in
\cite{cassandras2009introduction}. \pagebreak
\begin{definition}[Language]
  \label{def:language}~\\
  A Language defined over an alphabet $\Sigma$ is formed from finite-length
  words generated from the concatenation of the events in $\Sigma$ and
  $\epsilon$.
\end{definition}

Take for example an alphabet $\Sigma = \{a,b,g\}$, we can define different
languages
\begin{subequations}
  \begin{equation*}
  L_1=\{\epsilon, a, abb\}
  \end{equation*}
  \begin{equation*}
  L_2=\{\text{all possible words of length 3 starting with g}\}
  \end{equation*}
  \begin{equation*}
  L_3=\{\text{all possible words starting with g}\}
  \end{equation*}
\end{subequations}

The cardinality of this sets are $|L_1|=3$, $|L_2|=9$, $|L_3|=\infty$
As we can see from the same alphabet very different languages can be created, thus we can define a way to encapsulate all possible languages generated from
the same alphabet $\Sigma$. Let us denote by $\Sigma^*$ the set containing all
finite words composed with the elements of $\Sigma$ and $\epsilon$. The *
operation is called the \textit{Kleene-closure}. Similarly to $L_3$ it is
countably infinite since it contains arbitrarily long words. For instance the
\textit{Kleene-closure} of the alphabet $\Sigma = \{a, b, c\}$ is:
\begin{equation*}
  \label{eq:kleeneExample}
  \Sigma^* = \{\epsilon,a,b,c,aa,ab,ac,ba,bb,bc,ca,cb,cc,aaa,\dots\} 
\end{equation*}
There are a few operations with languages and alphabets that can be defined, but they are outside the scope of this work, they can be found on \cite{cassandras2009introduction}.
\section{Representation of Languages}
\label{sec:representationLanguages}

Although languages can describe the behaviour of \DESs, there are cases, as the
one shown
by the language $L_3$ in the last section, in which the language is enormous, in
that case countably infinite, what makes them not so simple to communicate the
behaviour of the system. For this purpose, there are some other formalisms that
aid the comprehension, since they can be a more compact way of expressing the
system's behaviour or accompanied by diagrams.

In the following subsections two of the most known representations will be
presented: Automata and Petri Nets.

\pagebreak
\subsection{Automata}
\label{sec:automata}
One of the most known representation of languages are automata. The notion of
automaton is basically the definition of \DESs, as we saw in the
\autoref{sec:discreteEventSystems}: a set of events can change the state of the
system. If we know all the events composing the language of the
system and its states, we can have its alphabet $\Sigma$ and we can create a set $X$ composed
by all states.
From $\Sigma$ and $X$ we can derive a function that represents the transition
from a state to other, this function is called \emph{transition function} of the automaton
denoted as $f : X \times \Sigma \rightarrow X$. For example if a system have an
alphabet $\Sigma = \{a,b\}$ and 2 states, we can name the states $x$ and
$y$, and then create the set $X = \{x,y\}$. Knowing that the system begins at state $x$
and that when event $a$ happens it changes to state $z$ we can create a function
$f(x,a)$ and define it as $y$. Likewise if we know that when the system is at
state $y$ and event $b$ happens, a function $f(y,b)$ can be defined as $a$.

As a
visual aid, a representation of these functions can be made through a diagram, called \emph{state transition diagram}. In this kind of diagram the states are
represented by circles labeled with their names, and the functions as arcs
labeled with the corresponding event,connecting two states, with arrows in one of their
extremities indicating the transition from a state to other. The initial state
of the automaton has an arc pointing towards it coming from no other state.
\autoref{fig:functionDiagram} can represent the functions $f(x,a)$ and $f(y,b)$
described in the last paragraph.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.3\textwidth]{automata/function/function.tikz}
  \caption{State Transition Diagram}
  \label{fig:functionDiagram}
\end{figure}
Now, for a more complex example, from \cite{cassandras2009introduction}:

\begin{example}[Simple Automaton] ~\\
  \label{ex:simpleAutomaton}
  Given $\Sigma = \{a,b,g\}$, $X = \{x,y,z\}$ and the following transition functions:
  \begin{align*}
   f(x,a)&=x&f(x,g)&=z\\
   f(y,a)&=x&f(y,b)&=y\\
   f(z,b)&=z&f(z,a)&=f(z,g)=y\\
 \end{align*}
\end{example}
We can represent this automaton with the diagram on \autoref{fig:diagramExapleAutomata}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{automata/example/example.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Diagram representing the automaton from example \ref{ex:simpleAutomaton}}
  \label{fig:diagramExapleAutomata}
\end{figure}
We can also mark states that have some special meaning, a final state for instance. In this work, as in \cite{cassandras2009introduction} they are
  going to be identified by double circles.

  
  Now a deterministic Automaton can be defined:
\begin{definition}[Deterministic Automaton]
  \label{def:DeterministicAutomaton}~\\
  A Deterministic Automaton, denoted by G, is a five-tuple
  \[ G = (X,\Sigma,f, x_0,X_m)\] where:

  \indent X is the set of \textbf{states} \\
  \indent $\Sigma$ is the finite set of \textbf{events} associated with G\\
  \indent f: X $\times \Sigma \rightarrow X$ is the \textbf{transition function}  \\
  \indent $x_0$ is the \textbf{initial state} \\
  \indent $X_m \subseteq X $ is the set of \textbf{marked states}

\end{definition}


Other kinds of automata and operations between automata exist but are not going
to be used in this work, again \cite{cassandras2009introduction} present them.

\subsection{Petri Nets}
\label{sec:petriNets}
Another kind of representation of languages are Petri Nets, whose concept was created by C.A.Petri
in the early 1960's. Differently from the automata representation that are
basically formed from states, Petri nets are bipartite graphs, formed by nodes
called \emph{places} and \emph{transitions}.
Transitions represent the events that drive the system, and places represent the
conditions for these events to happen. The mechanism to represent the fulfilment
of the conditions
is named marking. A petri net is built over three basic concepts, the petri net
graph\slash structure, its marking and firing transitions.
The next subsections will be based on \cite{david2005discrete} and \cite{cassandras2009introduction}.

\subsubsection{Petri Net Graph}
\label{sec:petrinetGraph}
Similarly, arcs are used to connect
the nodes and have arrowheads to identify the direction,
but differently, all arcs must have exclusively one node at each end, that means
no arc is used to identify the initial state of a petri net. As said, a petri net is
bipartite graph, that means places can only connect to transitions and vice
versa. In this work as in \cite{david2005discrete} places will be represented by
circles and transitions by bars. 
\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
  \centering
  \includegraphics{petriNet/net/place.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{A place.}
\end{subfigure}
~
\begin{subfigure}[t]{0.5\textwidth}
  \centering
  \includegraphics{petriNet/net/transition.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{A transition}
\end{subfigure}
  \caption{Component nodes of a petri net.}  
\end{figure}

The same way a function was created to define the transitions of states in an
automaton, two functions will be created to define the connections between places
and transitions. First we need to define the sets of places and transitions. $P$
is the set of places and $T$ the set of transitions. With this two sets we can
then define those functions. The first one represents the arcs
from places to transitions, and is denoted as $Pre: P \times T \rightarrow
\{0, 1\}$, the second one the arcs that connects transitions to places, denoted
as $Post: P \times T \rightarrow \{0,1\}$. The value $1$ is attributed to arcs
that exist and $0$ to the nonexistent ones.


\begin{example}[Simple Petri Net structure] ~\\
  \label{ex:simplePetriNetStructure}
  Given $P = \{p_0,p_1\}$, $T = \{t_0,t_1,t_2\}$ and the following transition
  functions:
  \begin{align*}
   Pre(p_0,t_0)& = 0  &  Post(p_0,t_1) &= 0 & Pre(p_1,t_0) &= 0 &  Post(p_1,t_1) &= 1 \\
   Post(p_0,t_0) &= 0  &    Pre(p_0,t_2) &= 0   & Post(p_1,t_0) &= 0   & Pre(p_1,t_2) &= 0\\
   Pre(p_0,t_1) &= 0    &  Post(p_0,t_2) &= 0  &  Pre(p_1,t_1) &= 0     &Post(p_1,t_2) &= 0\\
  \end{align*}
  We can represent this petri net structure with the diagram on \autoref{fig:simplePetriNetStructure}
\end{example}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{petriNet/prepost/prepost.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Diagram representing the petri net structure from example \ref{ex:simplePetriNetStructure}}
\label{fig:simplePetriNetStructure}
\end{figure}
A drawback from the definition of this functions, is that is not possible to
have more than an arc linking two nodes, so we can generalize them to any natural number:
\begin{align*}
  Pre:  P \times T \rightarrow \mathbb{N}_0\\
  Post: P \times T \rightarrow \mathbb{N}_0
\end{align*}
with this new definition we can change the definition of $Post(p_1,t_1)$ from
$0$ to $2$ resulting on the following petri net structure.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{petriNet/prepost/prepost2.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Diagram representing the petri net structure from example
    \ref{ex:simplePetriNetStructure}, but with $Post(p_1,t_1)=2$}
\label{fig:simplePetriNetStructureNatural}
\end{figure}
In order to reduce the number of arcs in a diagram, usually only one arc is
drawn and a label is added with the value of its respective function, if it is
greater than $1$, \autoref{fig:simplePetriNetStructureGeneralized} illustrates it:
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{petriNet/prepost/prepost3.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Same diagram as \autoref{fig:simplePetriNetStructureNatural} but with
    labeled arcs.}
\label{fig:simplePetriNetStructureGeneralized}
\end{figure}

\subsubsection{Marking}
\label{sec:marking}

As said in the beginning of this subsection marking is used as the mechanism to
represent if the condition of occurrence of a determined event is met or not.
But also it can be used to represent the state of the system. The mechanism
works as follows. Tokens can be designated to places and the way the tokens are
distributed among places is called the marking of a petri net graph. We can define a marking function $x :
P \rightarrow \mathbb{N}$ that denotes the number of tokens in a determined place.
In this
work, as in the majority of articles and books, the tokens will be
represented as black dots inside the places. 

The
\Autoref{fig:unmarked,fig:marked} show an unmarked and a marked petri net graph.
\begin{figure}[H]
\begin{subfigure}[t]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{petriNet/net/unmarked.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Unmarked}
  \label{fig:unmarked}
\end{subfigure}
~
\begin{subfigure}[t]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{petriNet/net/marked.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Marked}
  \label{fig:marked}
\end{subfigure}
\caption{Example of unmarked and marked petri net graphs.}
\end{figure}

The marking of a petri net, can be represented as a
vector of the function $x$ applied on all places, for example the marking of the
\autoref{fig:marked} is the following vector $\mathbf{x}$

\begin{equation*}
\mathbf{x}=\begin{bmatrix}
  x(p_0)\\
  x(p_1)\\
  x(p_2)\\
  x(p_3)\\
  x(p_4)\\
  x(p_5)\\
  x(p_6)
\end{bmatrix} =
\begin{bmatrix}
  1\\
  0\\
  1\\
  0\\
  0\\
  2\\
  0
\end{bmatrix}
\end{equation*}

This vector $\mathbf{x}$, the marking of the petri net, can be identified as the
state of the petri net. So, different configurations of tokens mean different
states of the system, now we only need a way to change from a state to other, in
other words, move the tokens.

\subsubsection{Firing Transitions}
\label{sec:firingTransitions}
The mean of move the tokens is firing transitions. When an event  happens and
the corresponding transition is enabled, this transition is fired and tokens
are moved between places.
We can define the functions $I : T \rightarrow 2^P$ and $O : T \rightarrow 2^P$ that
describe the set of places considered as inputs and outputs of a transition: 
\begin{align*}
  I(t_j)= \{p \in P : Pre(p,t)> 0\}\\
  O(t_j)= \{p \in P : Post(p,t)> 0\}\\
\end{align*}
\pagebreak
\begin{definition}[Enabled transition]
  \label{def:enabledTransition}~\\
  A transition is enabled if
  \[ x(p_i)\geq Pre(p_i,t_j) \text{ for all }{p_i \in I(t_j)}\]
  if $I(t_j)=\emptyset$, $t_j$ is always enabled. 
\end{definition}

And we can define the dynamic of the petri net, how the tokens move: 

\begin{definition}[Petri net dynamics]
  \label{def:petriNetDynamics}~\\
   It is possible to define a \emph{state transition}
  function, $f : \mathbb{N}^n \times T \rightarrow \mathbb{N}^n$  , where $n$ is
  the length of the state vector $\mathbf{x}$. This function $f$ is defined for
  a transition $t_j \in T$ if and only if this transition is enabled. If
  $f(\mathbf{x},t_j)$ is defined, then we create a new state vector
  $\mathbf{x}^\prime$:

  \[ x^\prime(p_i) = x(p_i) - Pre(p_i,t_j) + Post(p_i,t_j), i=1,\dots n \]
\end{definition}
  
As an example we can take \Autoref{fig:petriNetDynamics}:
\begin{figure}[H]
  \centering
 \begin{subfigure}[t]{0.45\textwidth}
  \centering
  \includegraphics{petriNet/net/beforeFiring.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Before firing.}
  \label{fig:beforeFiring}
\end{subfigure}
~
\begin{subfigure}[t]{0.45\textwidth}
  \centering
  \includegraphics{petriNet/net/afterFiring.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{After firing.}
  \label{fig:afterFiring}
\end{subfigure}
  \caption{Example of petri net Dynamic.}
  \label{fig:petriNetDynamics}
\end{figure}
The state before firing transition $t_0$ is $\mathbf{x}=\begin{bmatrix}3&
  0\end{bmatrix}^T$ and as we see $Pre(p_0,t_0)=2$ and $Post(p_1,t_0)=1$ so
applying the petri net dynamic we can find the next state $\mathbf{x}^\prime=\begin{bmatrix}1&
  1\end{bmatrix}^T$

Once all these fundamentals are presented we can finally define a Petri Net

\begin{definition}[Petri net]
  \label{def:petriNet}~\\
  A Petri net is defined as a five-tuple
  \[PN = (P,T,Pre,Post,\mathbf{x}_0)\]
  where: \\
  \indent $P$ is the set of \textbf{places} \\
  \indent $T$ is the set of \textbf{transitions} \\
  \indent $Pre$ is the \textbf{input incidence} function  \\
  \indent $Post$ is the \textbf{output incidence} function\\
\indent $\mathbf{x}_0$ is the initial marking of the net \\
And its dynamic is ruled by the \emph{state transition} function $f$ defined at \ref{fig:petriNetDynamics}.

\end{definition}

To make the connection between the Petri net and the events of the system, called $\Sigma$, the alphabet, we can
define a labeling function, $l : T^* \rightarrow \Sigma^*$ that makes the link between a
sequence of firing transitions and a sequence of events. But each transition
can only have one respective event. 

\begin{definition}[Labeled Petri net]
  \label{def:petriNet}~\\
  A Labeled Petri net is defined as a seven-tuple
  \[PN = (P,T,Pre,Post,\mathbf{x}_0,\Sigma,l)\]
  where: \\
  \indent $(P,T,Pre,Post,\mathbf{x}_0)$ is a Petri Net\\
  \indent $\Sigma$ is the set of \textbf{events} \\
  \indent $l$ is the \textbf{labeling} function  \\
\end{definition}

Usually the events are represented in the petri net graph over its respective
transition as shown in the \autoref{fig:labeledPetriNet}. This system has an alphabet
$\Sigma=\{a,b\}$ and labeling functions $l(t_0)=a$ and $l(t_1)=b$.

\begin{figure}[H]
  \centering
  \includegraphics{petriNet/labeled/labeled.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Labeled Petri net.}
  \label{fig:labeledPetriNet}
\end{figure}

\section{Control Interpreted Petri Nets}
\label{sec:cipn}
One of the greatest uses of Petri Nets, besides modeling a system, is its
ability to model the control of a system. For this intent we use Control Interpreted Petri nets. It is an
extension from the labeled Petri net, we add actions for places, so it is
possible to change the outputs of the system, conditions to the transitions, so it
is possible to change the state of the control based on the inputs of the
system, and even the ability to delay the firing transitions based on time.
Another artifice used is an inhibitor arc, that prevents the firing of a
transition based on the marking of the corresponding place.

\begin{definition}[Control Interpreted Petri net]
  \label{def:cipn}~\\
  A Labeled Petri net is defined as a seven-tuple
  \[PN = (P,T,Pre,Post,\mathbf{x}_0,In,\Sigma,C,l_C,D,L_D,A,I_A)\]
  where: \\
  \indent $(P,T,Pre,Post,\mathbf{x}_0)$ is a Petri Net\\
  \indent $In$ is the \textbf{inhibitor arc} function that prevents the
  enablement of transitions \\
  \indent $\Sigma$ is the set of \textbf{events} associated to transitions \\
  \indent $C$ is the set of \textbf{conditions} associated to transitions \\
  \indent $l_C$ is the \textbf{labeling} function that associates a transition
  with events and conditions from $\Sigma$ and $C$\\
  \indent $D$ is the set of \textbf{delays} associated to transitions \\
  \indent $l_D$ is the \textbf{labeling} function that associates a transition with a delay from $D$ \\
  \indent $A$ is the set of \textbf{actions} associated to places \\
  \indent $l_A$ is the \textbf{labeling} function that assigns actions from $A$ to a place \\
\end{definition}
The definition of $In : (P \times T )\rightarrow\mathbb{N}$ is that a transition
$t_j$ is inhibited if $x(p_i)\geq In(p_i,t_j)$. Inhibitor arcs are not used in
this work but usually they are represented with an arc with a circle in one of
its ends, as shown in \autoref{fig:inhibitor}.

\begin{figure}[H]
  \centering
  \includegraphics{petriNet/inhibitor/inhibitor.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Example of Petri net with inhibitor arc.}
  \label{fig:inhibitor}
\end{figure}
As we can see from the definition there are two labeling functions to connect 
transitions, $l_C$ and $l_D$. The $l_c$ is defined for transitions with no
firing delay and $l_D$ for transitions with firing delay.

The labeling function $l_C : T^0\rightarrow(\Sigma \times C)$ defines a pair of
event and boolean condition from $\Sigma$ and $C$ respectively. A transition
$t_i$ belonging to $T^0$ (a subset of $T$ that represents the transitions with
no time delay) has a corresponding event, condition tuple $(\sigma_i,c_i)$
For example, take a transition $t_0$, $\Sigma =\{\sigma_0\}$ and $C=\{c_0\}$. If
a function $l_c(t_0)=(\sigma_0,c_0)$ is defined, this transition will be fired
when the condition $c_0$ is true and the event $\sigma_0$
happens, but obviously, if and only if this transitions is enabled and not
inhibited. The transition $t_0$ is represented graphically as shown in \autoref{fig:condition}

\begin{figure}[H]
  \centering \includegraphics[width=0.3\textwidth]{petriNet/cipn/condition.tikz}
  \caption{Representation of new labeling function}
  \label{fig:condition}
\end{figure}

If the event is missing from the representation of the transition, it is equal
to the $\lambda$
, the always occurring event. And if the condition is missing, that means it is
equal to $1$, it is always $true$. If both are missing, that means the
transition will be automatically executed if it is enabled. 

By the other hand, the labeling function $l_D : T^D \rightarrow D$, defines a delay for the
transition to be fired. A timed transition $t_i$, a transition in $T^D$ (a subset of T
that represents the transitions with a time delay), has a corresponding delay
$d_i$. As an example, take a timed transition $t_1$ and $D=\{d_1\}$, after the
enablement of the transition, it takes $d_1$ time units in order to be fired. In
this work timed transitions are represented as bars slightly larger than normal
conditions. An example of this representation we can see \autoref{fig:timedtransition}

\begin{figure}[H]
  \centering \includegraphics[width=0.3\textwidth]{petriNet/cipn/timedtransition.tikz}
  \caption{Representation of a timed transition.}
  \label{fig:timedtransition}
\end{figure}
Another labeling function that was created is $l_A : P\rightarrow 2^A$,
assigning a set of actions belonging to $A$ to a place. Actions can be impulsive or continuous. A
continuous action happens always that the marking of a place is greater than 0,
$x(p_i)>0$, an impulsive, on the other hand, happens only when the marking of
the place changes from 0 to a value greater than 0. 
Actions are represented graphically as labels in places. Impulsive actions are differed by a star (*) at its end. So an action $F$ is
continuous and $B^*$ is impulsive. 
\autoref{fig:actions} show a representation of a Place with both kinds of actions.
\begin{figure}[H]
  \centering \includegraphics[width=0.3\textwidth]{petriNet/cipn/actions.tikz}
  \caption{Representation of labeling of Actions.}
  \label{fig:actions}
\end{figure}

Although these representations exist, in this work events, conditions and
actions labels are suppressed from the diagrams and tables accompany the drawings
showing the meaning of the transitions (firing events and conditions) and places
(Actions). This choice was made because when the controlled interpreted Petri nets
are very
large as the ones shown in the next chapters, if the events, conditions and
actions labels are long they can increase the size of the
diagram.

To illustrate this better we give an example based on one example from \cite{david1989grafcet}.
\begin{example}[Loading of a wagon] ~\\
  \label{ex:loadingOfAWagon}
We consider the system represented by the scheme in
\autoref{fig:cipnexamplescheme}. A wagon can be moved between the points $a$ and
$b$, using the inputs $L$ and $R$ (moving it to the left or right,
respectively). At point $a$ there is a button $m$ that can be pressed by an
operator and a limit switch called $a$ that is activated when the wagon is on
the left. At point $b$, an homonym limit switch is placed and activated when the
wagon is on the right. There is a hopper that can
be opened when the input $Open$ is turned on and closed when not.If it is opened
its content is poured. There is also a
button $p$ that is activated when the weight applied over the plate is equal or
greater to the weight of a full wagon. 

The objective of the control is, when the wagon is in its leftmost position and
the button $m$ is pressed, it moves to the right, stops at $b$, the hopper is
opened and the wagon is loaded, when it is completely full it moves to the left
and it stops at $a$ waiting to be unloaded and for a next press of $m$ to recommence
the loop. 
\end{example}


\begin{figure}[H]
  \centering \includegraphics[width=0.8\textwidth]{cipnExample/scheme.tikz}
  \caption[cipnexample]{Example of System to be controlled by the Petri Net}
  \label{fig:cipnexamplescheme}
\end{figure}
From the description of the control it is possible to create a Control Interpret
Petri Net to describe it, as the one in \autoref{fig:cipnexample}


\begin{figure}[H]
  \centering \includegraphics[width=0.8\textwidth]{cipnExample/cipn.tikz}
  \caption[cipnexample]{Example of Control Interpreted Petri Net to control
    system in \autoref{fig:cipnexamplescheme}}
  \label{fig:cipnexample}
\end{figure}

The meaning\slash description of each place and transition is given by the
following tables:

\input{../../figures/cipnExample/cipnPlaces}
\input{../../figures/cipnExample/cipnTransitions}

In this work as in the usual boolean notation, when just the name of a variable is given in a table it means the
variable is equal to true, and when there is a bar in its top it is equal to
false, so they determine conditions. E.g.: $b$ and $\overline{b}$.
And when a variable is preceded by $\uparrow$ and $\downarrow$, they  determine
events corresponding to its raising and falling edge.

\usetikzlibrary{arrows,shapes,circuits.plc.ladder,external}

\section{Implementation of Control Interpreted Petri Nets}
\label{sec:implementPetriNets}
Once the control of a system is modeled by a \CIPN, it
is needed to implement the control in a real controller. The most used
controllers in the industry are \PLCs. The international standard IEC 61131,
defines all the standards for \PLCs, and its third part (IEC 61131-3) defines
five languages to program \PLCs: \LD, Function Block Diagram
(FBD),  Structured Text (ST), Instruction List (IL) and Sequential Function
Chart (SFC). One of the most used in the industry is \LD, because of its
resemblance with electric connections. So we are going to use \LD{} to implement the
control designed with the \CIPN.

\subsection{Ladder Logic}
\label{sec:ladder}

The ladder logic is based on two components, contacts and coils. Their terminals are
interconnected to transmit boolean signals. This connection is similar to the
ladder physical implementation, from where came its inspiration, the components
were connect to boards and they formed electric circuits, turning on and off
motors and other actuators, based on the combination of its inputs. The logic
values in a \LD
are transmitted from the left to the right of the diagram. The components let
the logic ``current'' flow from its left terminal to the right terminal
depending on some conditions, and these conditions vary from component to component.
 The graphical representation of the most used types of contacts and coils
can be seen in \Autoref{fig:contacts,fig:coils}

\newlength{\ladderskip}
\newlength{\ladderrungsep}

% Types of Contacts
\begin{figure}[H]
\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/contactNO.tikz}
  \caption{Normally Opened Contact.}
  \label{fig:contactNO}
\end{subfigure}
~
\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/contactNC.tikz}
  \caption{Normally Closed Contact.}
  \label{fig:contactNC}
\end{subfigure}
\vspace{1em}

\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/contactP.tikz}
  \caption{Positive Edge Contact.}
  \label{fig:contactP}
\end{subfigure}
~
\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/contactN.tikz}
  \caption{Negative Edge Contact.}
  \label{fig:contactN}
\end{subfigure}

  \caption{Types of Contacts.}
  \label{fig:contacts}
\end{figure}

% Types of Coils
\begin{figure}[H]
\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/coilNO.tikz}
  \caption{Coil.}
  \label{fig:contactNO}
\end{subfigure}
~
\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/coilNC.tikz}
  \caption{Negated Coil.}
  \label{fig:contactNC}
\end{subfigure}
\vspace{1em}

\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/coilSet.tikz}
  \caption{Set (latch) Coil.}
  \label{fig:contactP}
\end{subfigure}
~
\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/coilReset.tikz}
  \caption{Reset (unlatch) Coil.}
  \label{fig:contactN}
\end{subfigure}

  \caption{Types of Coils.}
  \label{fig:coils}
\end{figure}

\subsubsection{Contacts}
Contacts represent the conditions of the ladder logic depending on inputs. These inputs can be any variable in a
\PLC, an external input ( sensors of the system to be controlled), a variable stored in memory or the current
value sent to an output from the \PLC. A normally opened contact
activates its right terminal (set it to $true$) if the logic value in its left terminal
is $true$ and its corresponding input is equal to $true$ 
A normally closed contact activates its right terminal if the logic value in its
left terminal is $true$ and its corresponding input is equal to $false$.
The Positive Edge contact activates its right terminal only in the instant that
its input change from logic value $false$ to $true$, if the logic value in its
left terminal is $true$. And the Negative Edge contact activates its right
terminal only in the instant that its input change from logic value $true$ to
$false$.

As we can see, positive and negative contacts can be used to represent raising ($\uparrow$)
and falling edge  ($\downarrow$) events and normally opened and closed contacts
to represent conditions (and their negation).

\subsubsection{Coils}

Coils, by the other side represent the actuation in outputs. These
outputs can be a variable stored in memory or the outputs
of the controller (actuators of the system to be controlled, for instance). 
A coil sets its output variable to true if the logic value of its left terminal is $true$,
and sets the output to $false$ otherwise.
A negated coil does the exact opposite, sets the output value to true if the logic
value of its left terminal is $false$ and sets it to $true$ if the logic is
$true$.

A set coil (or latch) sets its output variable to $true$ if the logic value of its
terminal is $true$ and it remains $true$ until the variable is reset.
And a reset coil (or unlatch) sets its output variable to $false$ if the logic
value of its terminal is $true$ and it remains $false$ until the variable is
set.

\subsubsection{Combinational Logic}
In boolean logic, in order to show functional completeness, it is need to show a
complete set of connectives ( a set that can create all other logic connectives
as a combination of its elements ). A well-know complete set is $S=\{AND,NOT\}$,
binary conjunction and negation.
To show that the ladder logic is functional complete we need only to present how
to construct this two connectors in it.
The conjunction of two inputs, can be made using two contacts in series, as
shown in \autoref{fig:ladderSeries}
\begin{figure}[H]
  \centering \includegraphics{ladder/series.tikz}
  \caption{And logic in Ladder.}
  \label{fig:ladderSeries}
\end{figure}
In this case C will only be activated if A and B are equal to $true$. ($C=AB$)

The negation of a variable can be achieved by the use of a normally closed
contact (\autoref{fig:ladderNot}).
\begin{figure}[H]
  \centering \includegraphics{ladder/not.tikz}
  \caption{Not logic in Ladder.}
  \label{fig:ladderNot}
\end{figure}
C will only by activated if A is $false$. ($C=\overline{A}$)

Although all logic connectives can be constructed with this two connectors, the
OR connector can be achieved by the use contacts in parallel (\autoref{fig:ladderParallel}).
\begin{figure}[H]
  \centering \includegraphics{ladder/parallel.tikz}
  \caption{Or logic in Ladder.}
  \label{fig:ladderParallel}
\end{figure}

\subsubsection{Function Blocks and extensions}
In order to increase functionality some function blocks and 
extensions to contacts were created. We can see examples of theses blocks and
contacts in the next figure:

\begin{figure}[H]
   \centering
\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/ctu.tikz}
  \caption{Up counter.}
  \label{fig:ctu}
\end{subfigure}
~
\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/ton.tikz}
  \caption{On-delay timer.}
  \label{fig:ton}
\end{subfigure}

\begin{subfigure}[t]{0.45\textwidth}
  \centering \includegraphics{ladder/comp.tikz}
  \caption{Less or equal comparator.}
  \label{fig:comp}
\end{subfigure}
  \caption{Examples of function blocks.}
  \label{fig:functionBlocks}
\end{figure}

Up counters (\autoref{fig:ctu}) save the value of a counter in a $CV$ variable. Every raising edge
on input $CU$ it increments $CV$ value. If $CV=PV$, the logic value of output $Q$ 
is set to $0$. When the input $R$ is true $CV$ value is set to $0$ and the
output $Q$ set to false.

On-delay timers (\autoref{fig:ctu}) set a timer when input $IN$ is $true$
and save it to $ET$. If $ET=PT$, the logic value of output $Q$ is set to $true$.
But if, meanwhile the counting, the value of $IN$ returns to $false$, $ET$ is reset to
$0$.

Comparator contacts as the less or equal comparator in \autoref{fig:comp}, work
similarly to contacts, but instead of an input as a condition, there are two
inputs ($value1$ and $value2$) and the condition is a comparison between both of
them. In this case, the contact is activated once its left terminals' logic
value is $true$ and $value1\leq value2$.

Other blocks and functions can be found in the IEC 61131-3.

\subsection{Conversion from \CIPN{} to \LD}
\label{sec:cipnToLD}

A simple method of conversion from \CIPN{} to \LD is presented in
\cite{moreira2013bridging}.

It consists in dividing the \CIPN{} in 4 modules:
\begin{enumerate}
\item A module of external events\\
  To create conditions to the firing of transitions based on external events
  (inputs)
\item A module of firing conditions\\
  To indicate what condition will be fired using the $Pre$, and $In$ functions, the conditions found on the
  last module and time delays (if it is a timed transition 
  )
\item A module of Petri Net dynamics\\
Uses the $Pre$ and $Post$ functions to determine the tokens ``motion''
\item A module of actions\\
  Determines the places where each action is performed.
\end{enumerate}
In this work, the external events and firing conditions was combined in order to
reduce the size of the program. But every module will be described as in
\cite{moreira2013bridging}.

\subsubsection{External events}
As external events are associated with positive and negative edge of the inputs
of the system, in this module, positive and negative edge contacts are used to
detect the rising and falling edge events, and they are stored in variables
using coils, a variable is created for every event.

\subsubsection{Firing Conditions}
As said in \ref{sec:cipn}, for a transition $t_j$ to be fired, first it needs to be
enabled ($x(p_i)\geq Pre(p_i,t_j)$ for all $p_i\in I(t_j)$), not inhibited
($x(p_i)< In(p_i,t_j)$ for all $p_i\in I(t_j)$) and the conditions and events
$\sigma_jc_j$ are met or the delay $d_j$ is elapsed, depending on the kind of
transition.
As places can have multiple tokens, we can use $int$ variables to store the
number of tokens, and comparator contacts to determine if the transitions are
enabled and not inhibited. The time delays are implemented using on-delay
timers. The state of fulfilment of the conditions is stored in variables, one
for each transition.


\begin{figure}[H]
  \centering \includegraphics{cipnExample/cipnLadder.tikz}
  \caption[cipnexample]{Example of Control Interpreted Petri Net converted to
    Ladder.}
  \label{fig:cipnexampleLadder}
\end{figure}


\subsection{Petri Net divided in multiple PLCs}
\label{sec:multiplePlcs}

\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.5\textwidth}
    \center
    \includetikzfigure[width=\textwidth]{communicationPlcPN/communicationPlcPN}
    \caption{Petri Net on PLC 1.}
    \label{fig:communicationPlcPN}
  \end{subfigure}%
  ~
  \begin{subfigure}[t]{0.5\textwidth}
    \centering
    \includetikzfigure[width=\textwidth]{communicationPlcPN/communicationPlcPN1}
    \caption{Petri Net on PLC 2.}
    \label{fig:communicationPlcPN1}
  \end{subfigure}
  \caption{Example of Petri Net divided between 2 PLCs.}
\end{figure}


\begin{figure}[H]
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics{communicationPlcPN/communicationPlcPNLadder.tikz}
    \caption{Ladder Logic on PLC 1.}
    \label{fig:communicationPlcPN}
  \end{subfigure}%
  \hfill
  \begin{subfigure}[t]{0.45\textwidth}
    \centering
    \includegraphics{communicationPlcPN/communicationPlcPN1Ladder.tikz}
    \caption{Ladder Logic on PLC 2.}
    \label{fig:communicationPlcPN1}
  \end{subfigure}
  \caption{Example of Petri Net divided between 2 PLCs.}
\end{figure}
  

\autoref{fig:communicationPlcPN}

\section{Identification}
\label{sec:identification}



\begin{figure}[H]
  \centering
  \begin{tikzpicture}
        % \draw[help lines,xstep=1,ystep=1] (0,0) grid (10,10);
        % \foreach \x in {0,1,...,10} { \node [anchor=north] at (\x,0) {\x}; }
        % \foreach \y in {0,1,...,10} { \node [anchor=east] at (0,\y) {\y}; }
        
        \draw[ultra thick,rounded corners] (3.5,0) rectangle (6.5,1.5);
        \draw[ultra thick,rounded corners] (0.5,2) rectangle (3.5,3.5);
        \draw[ultra thick,rounded corners] (6.5,2) rectangle (9.5,3.5);
        \draw[ultra thick,rounded corners] (3.5,4.5) rectangle (6.5,6);
        \draw (5,5.25) node {Controller};
        \draw (5,0.75) node {Plant};
        \draw (2,2.75) node {Actuators};
        \draw (8,2.75) node {Sensors};

        % actuators to plant
        \draw[->,>=stealth, very thick] (2,2) -- (2,0.75) -- (3.5,0.75);

        % controller to actuators
        \draw[->,>=stealth, very thick] (3.5,5.25) -- (2,5.25) -- (2,3.5);

        % Plant to sensors
        \draw[->,>=stealth, very thick] (6.5,0.75) -- (8,0.75) -- (8,2);

        % Sensors to controller
        \draw[->,>=stealth, very thick] (8,3.5) -- (8,5.25) -- (6.5,5.25);

        \draw[->,>=stealth, very thick] (2,4) -- (10,4);
        \draw[fill] (2,4) circle(.05);

        \draw[->,>=stealth, very thick] (8,4.5) -- (10,4.5);
        \draw[fill] (8,4.5) circle(.05);

        \draw (11,4.5) node {Observed};
        \draw (11,4.15) node {signals};

        \draw (1.5,5.75) node {Controller outputs};
        \draw (8.5,5.75) node {Controller inputs};

    \end{tikzpicture}
  \caption{Input\slash Output Process model}
    \label{fig:ioProcModel}
\end{figure}
\subsection{DAOCT}

\begin{definition}[Deterministic Automaton With Outputs and Conditional
  Transitions (DAOCT)]
  \label{def:daoct}~\\
  A Deterministic Automaton, denoted by DAOCT, is a nine-tuple
  \[ DAOCT = (X,\Sigma,f,\lambda,R,\theta, x_0,X_f)\] where:

  \indent X is the set of \textbf{states} \\
  \indent $\Sigma$ is the finite set of \textbf{events}\\
  \indent $\Omega \subset \mathbb{N}_1^{m_i+m_o} $ is the set of \textbf{I/O vectors}\\
  \indent f: X $\times \Sigma^\star \rightarrow X$ is the \textbf{deterministic transition function}  \\
  \indent $\lambda : X \rightarrow \Omega$ is the \textbf{state output function} \\
  \indent $R = {1,2,\dots,r}$ is the set of \textbf{path indices} \\
  \indent $\theta : X \times \Sigma \rightarrow 2^R$ is the \textbf{path
    estimation function} \\
  \indent $x_0$ is the \textbf{initial state} \\
  \indent $X_f \subseteq X $ is the set of \textbf{final states}
\end{definition}

Identification algorithm adapted from \cite{moreira2018enhanced}
\begin{algorithm2e}
  \caption{Identification Algorithm}\label{alg:identification}
  \KwIn {%
    Modified observed paths $p_i^k$, for i= 1,\dots,$r$ } \KwOut {%
    DAOCT =
    $($\XSet,\SigmaSet,\OmegaSet,\ffunction,\lambdafunction,\RSet,\thetafunction,\xZero,\XfSet$)$
  } \BlankLine Create an initial state $x_0$, and define $\lambda(x_0) =
  \tilde{\lambda}(x_0) = y_{1,1}$

  $X = \{ x_0\}, X_f = \emptyset, R = \emptyset$

  \For{$i = 1$ \KwTo $r$} { $R = R \cup \{ i \}$
  
    \For{$j = 1$ \KwTo $l_i - 1$} { Find the State $x \in X $ such that
      $\tilde{\lambda}(x) = y_{i,j+1}$

      \eIf{$\tilde{\lambda}(s) \neq y_{i,j+1}$ for all $ s \in X$} { Create
        state $x^\prime$ and define $\tilde{\lambda}(x^\prime) = y_{i,j+1}$

        $X = X \cup \{ x^\prime\}$

        $\lambda(x^\prime) = \tilde{\lambda_l}(x^\prime)$

      } { Find $x^\prime \in X$ such that $\tilde{\lambda}(x^\prime) =
        y_{i,j+1}$ } $f(x,\sigma_{i,j}) = x^\prime$

      Add $i$ to $\theta(x,\sigma_{i,j})$

      \If{$j = l_i - 1$} { $X_f = X_f \cup \{x^\prime\}$ } } }
\end{algorithm2e}



\begin{figure}[H]
  \centering \includegraphics[width=\textwidth]{automata/daoct/example.tikz}
  % \includetikzfigure[width=0.5\textwidth]{automata/example/example}
  \caption{Diagram representing the DAOCT from example number }
\end{figure}

\usetikzlibrary{patterns}
\begin{figure}[H]
  \centering \includegraphics[width=0.5\textwidth]{vennDiagramLanguages.tikz}
  \caption{Venn diagram showing relations between $L_{Orig}$, $L_{OrigNI}$,
    $L_{Obs}$, $L_{Exc}$ and $L_{Iden}$}
\end{figure}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../monografia.tex"
%%% End:
